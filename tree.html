<!DOCTYPE html>
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta content='text/html;charset=UTF-8' http-equiv='content-type'>
    <title></title>

    <style>

    #tooltip{
    position:absolute;
    width:auto;
	max-width: 400px;
    height:auto;
    padding:10px;
    background-color:white;
    border-radius:10px;
    box-shadow: 4px 4px 10px rgba(0,0,0,0.4);

    }

    #tooltip.hidden{
      display:none;
    }

    #tooltip p{
      margin:0px;
      font-family:sans-serif;
      font-size:12px;
    }

    .node {
	  cursor: pointer;
	}

    .link_bold {
  		stroke: #000 !important;
  		stroke-width: 2px;
	}

	.link_extend_bold {
  		stroke-opacity: .6;
	}

	#searchBar{
		position: absolute;
		margin-left: 3em;
	}

	#instructions{
		margin-left: 3em;
	}

	h1{
      	margin:0px;
        font-family:sans-serif;
        font-size:28px;
        text-align:center;
    }

    h2{
        margin:5px;
        font-family:sans-serif;
        font-size:18px;
        text-align:center;
    }

    h3{
        margin:5px;
        font-family:sans-serif;
        font-size:14px;
        text-align:center;
    }

    h5{
        font-family:sans-serif;
        font-size:13px;
    }

    </style>

    <script src="http://d3js.org/d3.v3.min.js" type="text/javascript"></script>
    <script src="newick.js" type="text/javascript"></script>
	<body>
	<div>
		<h1>
			The Eukaryotic Tree of Life
		</h1>
		<h2>
			By Carter Merenstein and Hanna Nowicki
		</h2>
		<h3>
			Information Visualization Final Project
		</h3>
	</div>

	<div id="instructions">
		<h4> 
			Instructions
		</h4>
		<h5>
			Blah Blah Blah
		</h5>
	</div>

    <!-- tooltip div -->
    <div id="tooltip" class="hidden">
      Taxonomy: <span id="name"></span>
    </div>

    <!-- search bar div -->
    <div id="searchBar">
        <p>
            Enter a Species Name to Search: <input type="text" placeholder="Enter name" id="nameInput">
            <button id="searchButton">Search</button>
        </p>
    </div>

<!-- Copyright 2011 Jason Davies https://github.com/jasondavies/newick.js -->
<script>function parseNewick(a){for(var e=[],r={},s=a.split(/\s*(;|\(|\)|,|:)\s*/),t=0;t<s.length;t++){var n=s[t];switch(n){case"(":var c={};r.branchset=[c],e.push(r),r=c;break;case",":var c={};e[e.length-1].branchset.push(c),r=c;break;case")":r=e.pop();break;case":":break;default:var h=s[t-1];")"==h||"("==h||","==h?r.name=n:":"==h&&(r.length=parseFloat(n))}}return r}</script>
	
    <script>
		var width = 2000; // determines height of tree.
		var height = 2000;   
		var duration = 700;
		
		var relatedNodes = []; // global variable for relatedness feature.
 		var lca; // last common ancenstor
		var foundSpecies = []; //for searching a taxonomical unit
 		var nodeArray; //a global array of all the nodes
		
		var vis = d3.select("body").append("svg")
			.attr("width" , width)
			.attr("height", height)
			.append("g")
				.attr("transform", "translate(50, 50)");
				
	d3.csv("Euk.tree.annotations.csv", function (annotations) {	 
		console.log(annotations)
		d3.text("Euk.txt", function(error, euk) {
			if (error) throw error;
		  
		var findSpecies = function (node) {
			number = node.name;
			annotations.forEach( function (d) {
					if (+d.number == +number) {
						node.species = d.species;
						node.taxonomy = d.taxonomy.split("|")
						taxonomyStr = ""
						node.taxonomy.forEach(function (q) {
							taxonomyStr = taxonomyStr + " | " + q;
						});
						node.taxonomyStr = taxonomyStr;
						node.cool_name = d.cool_name;
					}
				});
				//return "";
			};
		// puts annotated info into the nodes;	
		var traverse = function(root_node){
			//console.log(root_node);
			var leaves = [];
			var commonTaxonomy = [];
			var commonTaxonomyStr = "";
			root_node.children = root_node.branchset
			if (typeof root_node.branchset == "undefined") {
				findSpecies(root_node);
				return root_node.taxonomy;
			}
			else {
				root_node.branchset.forEach(function (d) {
					leaves.push(traverse(d));
				});
				var min = 0;// shortest taxonomy
				leaves.forEach(function (d) {
					if (d.length > min) {
						min = d.length
					}
				})
				var i; 
				for (i = 0; i < min; i++) {
					// here we assume only 2 children. Didn't make that assuumption earlier but looking closer at our data, it is true.
					if (leaves[0][i] == leaves[1][i]) {
						commonTaxonomy.push(leaves[0][i]);
						commonTaxonomyStr = commonTaxonomyStr + " | " + leaves[0][i];
					} else {
						break;
					}
				}
			}
			root_node.taxonomy = commonTaxonomy;
			root_node.species = commonTaxonomy[commonTaxonomy.length - 1];
			root_node.taxonomyStr = commonTaxonomyStr;
			console.log(commonTaxonomy);
			return commonTaxonomy;
		};
		
		var tree = d3.layout.cluster()
			.size([width-100, height-100]);
			//.children(function(d) { return d.branchset; });
		var root = parseNewick(euk);
		console.log(root);
		root.parent = {x:0, y:0};
		console.log(root);

		traverse(root);
		console.log(root);
		
		// This changes the y values to be based off of the actual relatedness distance
		// also an offset seemed potentially helpful, so it's there.
		function adjustLength(n, offset) {
			  if (n.length != null) offset += n.length * 400;
			  n.y = offset;
			  if (n.children)
				n.children.forEach(function(n) {
				  adjustLength(n, offset);
				});
		}
		
		
		var	rightAngleDiagonal = function rightAngleDiagonal(d, i) {
			return "M" + d.source.y + "," + d.source.x
			+ "V" + d.target.x + "H" + d.target.y;
			}


		var bolded = function(is_mousedover){
			return function(d){
				d3.select(this).classed("link_bold", is_mousedover);
				d3.select(this.source).classed("link_bold", is_mousedover);
			}
		}
		
		function click(d){
			// this part is for the collapsing
			if (d.children) {
				d.children = null;
			  } else {
				d.children = d.branchset;
			  }
			
			// this part is for relatedness feature
			if (!d.branchset) {
				var nodeIndex = relatedNodes.indexOf(d);
				if(nodeIndex == -1){
					relatedNodes.push(d);
				}else{
					relatedNodes.splice(nodeIndex, 1);
					traverseAncestors(d, false); // this is for dehighlighting
					
				}

			}
			if (relatedNodes.length > 1) {
				colorRelated();
				relatedNodes.forEach(function (leaf) {
					traverseAncestors(leaf, true);
					});
			} else {
				lca = undefined;
				relatedNodes.forEach(function (leaf) {
					traverseAncestors(leaf, false);
					});
			}
			  update(d);
		}


		function name(node){
			if (node.children) {
				return "";
			}
			else {
				return node.species;
			}		
		}
		
		function makeAncestors(leaf){
			var temp = leaf.parent;
			var ancestors = [leaf.id];
			while (temp.parent) {
				ancestors.unshift(temp.id);
				temp = temp.parent;
			}
			leaf.ancestors = ancestors;
			console.log(ancestors);
		}
		// looks through ancestors and sets them as in the path, until get to the LCA
		function traverseAncestors(leaf, set_inpath){
			// we have to clear the path out regardless
			var temp = leaf;
			while (leaf.id != 0) {
				leaf.in_path = false;
				leaf = leaf.parent;
			
			}
			leaf = temp;
			if (set_inpath) {
				while (leaf.id != lca) {
					//console.log(leaf);
					leaf.in_path = true;
					leaf = leaf.parent;
				}
			}
		}
		
		// This is poorly named. It really just sets the LCA
		function colorRelated() {
			relatedNodes.forEach(function (d) {
				makeAncestors(d);
			});
			
			var prior = 0;
			var one_node_ancestors = relatedNodes[0].ancestors;
			console.log(one_node_ancestors);
			var j = 0;
			while (j < 25) { // arbitrary number, deeper than all leaves
				relatedNodes.slice(1,relatedNodes.length).forEach(function(d){
					console.log(d.ancestors[j] + "  " + one_node_ancestors[j]);
					
					if (d.ancestors[j] != one_node_ancestors[j]){
						j = 26; // to break out of the while
					}
				});
				if (j < 25) {
					prior = one_node_ancestors[j];
				}
				j++;
				//console.log(prior);
			}
			lca = prior;
			
		}


		//for the search bar
		d3.select("#searchButton").on("click", function(){
        	var name = document.getElementById("nameInput").value;
        	
        	foundSpecies = [];
        	var tax;

        	nodeArray.forEach(function(d){ //going through each of the nodes in tree
        		tax = d.taxonomy;
        		tax.forEach(function(f){ //going through each entry in taxonomy array
	        		if(f == name){  //if has that name in it's taxonomy
	        			foundSpecies.push(d.id);  //push it onto the array
	        		}
        		});
        	});

        	if(foundSpecies.length == 0){
        		console.log("No matches found");
        	}

        	update(root);
      	});


		
		var update = function (source) {
		
			var nodes = tree.nodes(root);

			nodeArray = nodes;

			adjustLength(nodes[0], 0);
					
			var links = tree.links(nodes);
				vis.selectAll(".link")
				.data(links)
				.enter()
				.append("path")
				.attr("class", "link")
				.attr("fill", "none")
				.attr("stroke", "black")
				.attr("d", rightAngleDiagonal)
				.on("mouseover", bolded(true))   
				.on("mouseout", bolded(false));
			
			var node = vis.selectAll("g.node")
				.data(nodes, function(d, i) { return d.id || (d.id = i); });

			var nodeEnter = node.enter()
				.append("g")
					.attr("class", "node")
					.attr("transform", function (d) {return "translate(" + d.y + "," + d.x + ")";})
					.on("click", click);

			nodeEnter.append("circle")
				.attr("r", 1e-6)
				.attr("fill", "dodgerblue")
				.on("mouseover", function(d){
				      var tooltip = d3.select("#tooltip");
	                 
	                  d3.select("#name").text(d.taxonomyStr);   //d.name or something
	                  
	                  tooltip.style({
	                    left: (d.y - 60) + "px",
	                    top: (d.x + 120 ) + "px",
	                  })
	                  .classed("hidden", false);
	               })
		           .on("mouseout", function(d) {
		              var tooltip = d3.select("#tooltip");
		              tooltip.classed("hidden", true);
		           })
		           .classed("node", true);
				// .on("mouseover", bolded(true))
				// .on("mouseout", bolded(false));


			nodeEnter.append("text")
				.attr("dx", 5)
				.attr("dy", 3)
				.style("font-size", "10px")
				.text(function (d) {return name(d)});
				
			var nodeUpdate = node.transition()
			  .duration(duration)
			  .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

			nodeUpdate.select("circle")
					.attr("r", function (d) {
							if (d.id == lca) {return 5;} else {return 2.5;}
						})
					.attr("fill", function (d) {
						//making selected nodes and their lca node red, all others blue
						if (relatedNodes.indexOf(d) != -1 || d.id == lca) {
							return "red"; 
						} 
						//for species found in the search bar
						else if(foundSpecies.indexOf(d.id) != -1 && foundSpecies.length == 1){
							return "darkorchid"; 
						}
						else {
							return "dodgerblue";
						}
					});
    
			nodeUpdate.select("text")
				.style("fill-opacity", 1)
				.style("font-size", function (d) { 
					if (d.branchset) { return "12px";} else {return "10px";} })
				.text(function (d) {return name(d)});
				
			
			// don't actually remove exit set, just put it under the parent
			var nodeExit = node.exit().transition()
			  .duration(duration)
			  .attr("transform", function(d) {return "translate(" + source.y + "," + source.x + ")"; });
			  //.remove();

			// make circle really small 
			nodeExit.select("circle")
			  .attr("r", 1e-6);

			// make text invisible
			nodeExit.select("text")
			  .style("fill-opacity", 1e-6);

			// update the links
			var link = vis.selectAll("path.link")
				.data(links, function(d) { return d.target.id; })
				.attr("stroke", function(d) { 
					if(d.target.in_path) { 
						return "red";
					}
					else if(foundSpecies.indexOf(d.source.id) != -1){
						return "darkorchid"; 
					} else {return "black";}		})
				.attr("stroke-width", function(d) { 
					if(d.target.in_path) { return "2px";} else {return "1px";}		});
	
			link.enter().insert("path", "g")
			  .attr("class", "link")
			  .attr("d", function(d) {
				var o = {x: source.x0, y: source.y0};
				return rightAngleDiagonal({source: o, target: o});
			  });
			  
			   // Transition links to their new position.
			
			
			link.transition()
			  .duration(duration)
			  .attr("d", rightAngleDiagonal);

			// Transition exiting nodes to the parent's new position.
			link.exit().transition()
			  .duration(duration)
			  .attr("d", function(d) {
				var o = {x: source.x, y: source.y};
				return rightAngleDiagonal({source: o, target: o});
			  })
			  //.remove();

			// Stash the old positions for transition.
			nodes.forEach(function(d) {
				d.x0 = d.x;
				d.y0 = d.y;
			});
			
		};
		update(root);
      });
	});
    </script>
    <style type="text/css" media="screen">
      body { font-family: "Helvetica Neue", Helvetica, sans-serif; }
      td { vertical-align: top; }
    </style>
  </head>
 
    
  </body>
</html>