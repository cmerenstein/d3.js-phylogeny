<!DOCTYPE html>
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta content='text/html;charset=UTF-8' http-equiv='content-type'>
    <title></title>

    <style>

    #tooltip{
    position:absolute;
    width:auto;
	max-width: 400px;
    height:auto;
    padding:10px;
    background-color:white;
    border-radius:10px;
    box-shadow: 4px 4px 10px rgba(0,0,0,0.4);

    }

    #tooltip.hidden{
      display:none;
    }

    #tooltip p{
      margin:0px;
      font-family:sans-serif;
      font-size:12px;
    }

    .link_bold {
  		stroke: #000 !important;
  		stroke-width: 2px;
	}

	.link_extend_bold {
  		stroke-opacity: .6;
	}
    </style>

    <script src="http://d3js.org/d3.v3.min.js" type="text/javascript"></script>
    <script src="newick.js" type="text/javascript"></script>
	<body>

    <!-- tooltip div -->
    <div id="tooltip" class="hidden">
      Taxonomy: <span id="name"></span>
    </div>

<!-- Copyright 2011 Jason Davies https://github.com/jasondavies/newick.js -->
<script>function parseNewick(a){for(var e=[],r={},s=a.split(/\s*(;|\(|\)|,|:)\s*/),t=0;t<s.length;t++){var n=s[t];switch(n){case"(":var c={};r.branchset=[c],e.push(r),r=c;break;case",":var c={};e[e.length-1].branchset.push(c),r=c;break;case")":r=e.pop();break;case":":break;default:var h=s[t-1];")"==h||"("==h||","==h?r.name=n:":"==h&&(r.length=parseFloat(n))}}return r}</script>
	
    <script>
		var width = 2000; // determines height of tree.
		var height = 2000;   
		var duration = 0;
		
		var relatedNodes = []; // global variable for relatedness feature.
 		var lca; // last common ancenstor

		var vis = d3.select("body").append("svg")
			.attr("width" , width)
			.attr("height", height)
			.append("g")
				.attr("transform", "translate(50, 50)");
	d3.csv("Euk.tree.annotations.csv", function (annotations) {	 
		console.log(annotations)
		d3.text("Euk.txt", function(error, euk) {
			if (error) throw error;
		  
		var findSpecies = function (node) {
			number = node.name;
			annotations.forEach( function (d) {
					if (+d.number == +number) {
						node.species = d.species;
						node.taxonomy = d.taxonomy.split("|")
						taxonomyStr = ""
						node.taxonomy.forEach(function (q) {
							taxonomyStr = taxonomyStr + " | " + q;
						});
						node.taxonomyStr = taxonomyStr;
					}
				});
				//return "";
			};
			
		var traverse = function(root_node){
			//console.log(root_node);
			var leaves = [];
			var commonTaxonomy = [];
			var commonTaxonomyStr = "";
			root_node.children = root_node.branchset
			if (typeof root_node.branchset == "undefined") {
				findSpecies(root_node);
				return root_node.taxonomy;
			}
			else {
				root_node.branchset.forEach(function (d) {
					leaves.push(traverse(d));
				});
				var min = 0;// shortest taxonomy
				leaves.forEach(function (d) {
					if (d.length > min) {
						min = d.length
					}
				})
				var i; 
				for (i = 0; i < min; i++) {
					// here we assume only 2 children. Didn't make that assuumption earlier but looking closer at our data, it is true.
					if (leaves[0][i] == leaves[1][i]) {
						commonTaxonomy.push(leaves[0][i]);
						commonTaxonomyStr = commonTaxonomyStr + " | " + leaves[0][i];
					} else {
						break;
					}
				}
			}
			root_node.taxonomy = commonTaxonomy;
			root_node.species = commonTaxonomy[commonTaxonomy.length - 1];
			root_node.taxonomyStr = commonTaxonomyStr;
			console.log(commonTaxonomy);
			return commonTaxonomy;
		};
		
		var tree = d3.layout.cluster()
			.size([width-100, height-100]);
			//.children(function(d) { return d.branchset; });
		var root = parseNewick(euk);
		console.log(root);
		root.parent = {x:0, y:0};
		console.log(root);

		traverse(root);
		console.log(root);
		
				
			
		function adjustLength(n, offset) {
			  if (n.length != null) offset += n.length * 400;
			  n.y = offset;
			  if (n.children)
				n.children.forEach(function(n) {
				  adjustLength(n, offset);
				});
		}
		
		
		var	rightAngleDiagonal = function rightAngleDiagonal(d, i) {
			return "M" + d.source.y + "," + d.source.x
			+ "V" + d.target.x + "H" + d.target.y;
			}


		var bolded = function(is_mousedover){
			return function(d){
				d3.select(this).classed("link_bold", is_mousedover);
				d3.select(this.source).classed("link_bold", is_mousedover);
			}
		}
		
		function click(d){
			// this part is for the collapsing
			if (d.children) {
				d.children = null;
			  } else {
				d.children = d.branchset;
			  }
			
			// this part is for relatedness feature
			if (!d.branchset) {
				relatedNodes.push(d);
			}
			if (relatedNodes.length > 1) {
				colorRelated();
			}
			  update(d);
		}

		function name(node){
			if (node.children) {
				return "";
			}
			else {
				return node.species;
			}		
		}
		
		function colorRelated() {
			var prior = "Eukaryota";
			var one_node_tax = relatedNodes[0].taxonomy;
			console.log(one_node_tax);
			var j = 0;
			while (j < 20) {
				relatedNodes.slice(1,relatedNodes.length).forEach(function(d){
					console.log(d.taxonomy[j] + "  " + one_node_tax[j]);
					
					if (d.taxonomy[j] != one_node_tax[j]){
						j = 21; // to break out of the while
					}
				});
				if (j < 20) {
					prior = one_node_tax[j];
				}
				j++;
				//console.log(prior);
			}
			
			lca = prior;
		}
		
		var update = function (source) {
		
			var nodes = tree.nodes(root);
			adjustLength(nodes[0], 0);
			
			var links = tree.links(nodes);
				vis.selectAll(".link")
				.data(links)
				.enter()
				.append("path")
				.attr("class", "link")
				.attr("fill", "none")
				.attr("stroke", "black")
				.attr("d", rightAngleDiagonal)
				.on("mouseover", bolded(true))   
				.on("mouseout", bolded(false));
			
			var node = vis.selectAll("g.node")
				.data(nodes, function(d, i) { return d.id || (d.id = i); });

			var nodeEnter = node.enter()
				.append("g")
					.attr("class", "node")
					.attr("transform", function (d) {return "translate(" + d.y + "," + d.x + ")";})
					.on("click", click);

			nodeEnter.append("circle")
				.attr("r", 1e-6)
				.attr("fill", "dodgerblue")
				.on("mouseover", function(d){
				      var tooltip = d3.select("#tooltip");
	                 
	                  d3.select("#name").text(d.taxonomyStr);   //d.name or something
	                  
	                  tooltip.style({
	                    left: (d.y - 60) + "px",
	                    top: (d.x + 90 ) + "px",
	                  })
	                  .classed("hidden", false);
	               })
		           .on("mouseout", function(d) {
		              var tooltip = d3.select("#tooltip");
		              tooltip.classed("hidden", true);
		           })
		           .classed("node", true);
				// .on("mouseover", bolded(true))
				// .on("mouseout", bolded(false));


			nodeEnter.append("text")
				.attr("dx", 5)
				.attr("dy", 3)
				.style("font-size", "10px")
				.text(function (d) {return name(d)});
				
			var nodeUpdate = node.transition()
			  .duration(duration)
			  .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

			nodeUpdate.select("circle")
					.attr("r", function (d) {
							if (d.species == lca) {return 5;} else {return 2.5;}
						})
					.attr("fill", function (d) {
						if (relatedNodes.indexOf(d) != -1) {return "red"; } else {return "dodgerblue";}
					});
    
			nodeUpdate.select("text")
				.style("fill-opacity", 1)
				.style("font-size", function (d) { 
					if (d.branchset) { return "12px";} else {return "10px";} })
				.text(function (d) {return name(d)});
				
			
			// don't actually remove exit set, just put it under the parent
			var nodeExit = node.exit().transition()
			  .duration(duration)
			  .attr("transform", function(d) {return "translate(" + source.y + "," + source.x + ")"; })
			  .remove();
			// make circle really small 
			nodeExit.select("circle")
			  .attr("r", 1e-6);
			// make text invisible
			nodeExit.select("text")
			  .style("fill-opacity", 1e-6);
			// update the links
			var link = vis.selectAll("path.link")
				.data(links, function(d) { return d.target.id; });
	
			link.enter().insert("path", "g")
			  .attr("class", "link")
			  .attr("d", function(d) {
				var o = {x: source.x0, y: source.y0};
				return rightAngleDiagonal({source: o, target: o});
			  });
			  
			   // Transition links to their new position.
			link.transition()
			  .duration(duration)
			  .attr("d", rightAngleDiagonal);

			// Transition exiting nodes to the parent's new position.
			link.exit().transition()
			  .duration(duration)
			  .attr("d", function(d) {
				var o = {x: source.x, y: source.y};
				return rightAngleDiagonal({source: o, target: o});
			  })
			  .remove();

			// Stash the old positions for transition.
			nodes.forEach(function(d) {
			d.x0 = d.x;
			d.y0 = d.y;
			});
			
		};
		update(root);
      });
	});
    </script>
    <style type="text/css" media="screen">
      body { font-family: "Helvetica Neue", Helvetica, sans-serif; }
      td { vertical-align: top; }
    </style>
  </head>
 
    
  </body>
</html>