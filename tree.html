
<!DOCTYPE html>
<html lang='en' xml:lang='en' xmlns='http://www.w3.org/1999/xhtml'>
  <head>
    <meta content='text/html;charset=UTF-8' http-equiv='content-type'>
    <title></title>

    <style>
    .link_bold {
  		stroke: #000 !important;
  		stroke-width: 2px;
	}

	.link_extend_bold {
  		stroke-opacity: .6;
	}
    </style>

    <script src="http://d3js.org/d3.v3.min.js" type="text/javascript"></script>
    <script src="newick.js" type="text/javascript"></script>
	 <body>
<!-- Copyright 2011 Jason Davies https://github.com/jasondavies/newick.js -->
<script>function parseNewick(a){for(var e=[],r={},s=a.split(/\s*(;|\(|\)|,|:)\s*/),t=0;t<s.length;t++){var n=s[t];switch(n){case"(":var c={};r.branchset=[c],e.push(r),r=c;break;case",":var c={};e[e.length-1].branchset.push(c),r=c;break;case")":r=e.pop();break;case":":break;default:var h=s[t-1];")"==h||"("==h||","==h?r.name=n:":"==h&&(r.length=parseFloat(n))}}return r}</script>
	
    <script>
		var width = 2000; // determines height of tree.
		var height = 2000;   
		var duration = 0;
		
		var vis = d3.select("body").append("svg")
			.attr("width" , width)
			.attr("height", height)
			.append("g")
				.attr("transform", "translate(50, 50)");
	d3.csv("Euk.tree.annotations.csv", function (annotations) {	 
		console.log(annotations)
		d3.text("Euk.txt", function(error, euk) {
			if (error) throw error;
		  
		var findSpecies = function (node) {
			number = node.name;
			annotations.forEach( function (d) {
					if (+d.number == +number) {
						node.species = d.species;
						node.taxonomy = d.taxonomy.split("|")
						node.taxonomyStr = d.taxonomy;
					}
				});
				//return "";
			};
			
		var traverse = function(root_node){
			//console.log(root_node);
			var leaves = [];
			var commonTaxonomy = [];
			root_node.children = root_node.branchset
			if (typeof root_node.branchset == "undefined") {
				findSpecies(root_node);
				return root_node.taxonomy;
			}
			else {
				root_node.branchset.forEach(function (d) {
					leaves.push(traverse(d));
				});
				var min = 0;// shortest taxonomy
				leaves.forEach(function (d) {
					if (d.length > min) {
						min = d.length
					}
				})
				var i; 
				for (i = 0; i < min; i++) {
					// here we assume only 2 children. Didn't make that assuumption earlier but looking closer at our data, it is true.
					if (leaves[0][i] == leaves[1][i]) {
						commonTaxonomy.push(leaves[0][i]);
					} else {
						break;
					}
				}
			}
			root_node.taxonomy = commonTaxonomy;
			root_node.species = commonTaxonomy[commonTaxonomy.length - 1];
			console.log(commonTaxonomy);
			return commonTaxonomy;
		};
		
		var tree = d3.layout.cluster()
			.size([width-100, height-100]);
			//.children(function(d) { return d.branchset; });
		var root = parseNewick(euk);
		console.log(root);
		root.parent = {x:0, y:0};
		console.log(root);

		traverse(root);
		console.log(root);
		
				
			
		function adjustLength(n, offset) {
			  if (n.length != null) offset += n.length * 200;
			  n.y = offset;
			  if (n.children)
				n.children.forEach(function(n) {
				  adjustLength(n, offset);
				});
		}
		
		
		var	rightAngleDiagonal = function rightAngleDiagonal(d, i) {
			return "M" + d.source.y + "," + d.source.x
			+ "V" + d.target.x + "H" + d.target.y;
			}


		var bolded = function(is_mousedover){
			return function(d){
				d3.select(this).classed("link_bold", is_mousedover);
				d3.select(this.source).classed("link_bold", is_mousedover);
			}
		}
		
		function click(d){
			console.log(d.children);

			if (d.children) {
				//console.log(d.children);
				d.children = null;
			  } else {
				d.children = d.branchset;
				//console.log(d.children);
			  }
			  update(d);
		}

		function name(node){
			if (node.children) {
				return "";
			}
			else {
				return node.species;
			}		
		}
		
		var update = function (source) {
		
			var nodes = tree.nodes(root);
			adjustLength(nodes[0], 0);
			
			var links = tree.links(nodes);
				vis.selectAll(".link")
				.data(links)
				.enter()
				.append("path")
				.attr("class", "link")
				.attr("fill", "none")
				.attr("stroke", "black")
				.attr("d", rightAngleDiagonal)
				.on("mouseover", bolded(true))   
				.on("mouseout", bolded(false));
			
			var node = vis.selectAll("g.node")
				.data(nodes, function(d, i) { return d.id || (d.id = i); });

			var nodeEnter = node.enter()
				.append("g")
					.attr("class", "node")
					.attr("transform", function (d) {return "translate(" + d.y + "," + d.x + ")";})
					.on("click", click);

			nodeEnter.append("circle")
				.attr("r", 1e-6)
				.attr("fill", "dodgerblue")
				.on("mouseover", bolded(true))
				.on("mouseout", bolded(false));
			nodeEnter.append("text")
				.attr("dx", 5)
				.attr("dy", 3)
				.style("font-size", "10px")
				.text(function (d) {return name(d)});
				
			var nodeUpdate = node.transition()
			  .duration(duration)
			  .attr("transform", function(d) { return "translate(" + d.y + "," + d.x + ")"; });

			nodeUpdate.select("circle")
					.attr("r", 2);
    
			nodeUpdate.select("text")
				.style("fill-opacity", 1)
				.style("font-size", function (d) { 
					if (d.branchset) { return "12px";} else {return "10px";} })
				.text(function (d) {return name(d)});
				
			
			// don't actually remove exit set, just put it under the parent
			var nodeExit = node.exit().transition()
			  .duration(duration)
			  .attr("transform", function(d) {return "translate(" + source.y + "," + source.x + ")"; })
			  .remove();
			// make circle really small 
			nodeExit.select("circle")
			  .attr("r", 1e-6);
			// make text invisible
			nodeExit.select("text")
			  .style("fill-opacity", 1e-6);
			// update the links
			var link = vis.selectAll("path.link")
				.data(links, function(d) { return d.target.id; });
	
			link.enter().insert("path", "g")
			  .attr("class", "link")
			  .attr("d", function(d) {
				var o = {x: source.x0, y: source.y0};
				return rightAngleDiagonal({source: o, target: o});
			  });
			  
			   // Transition links to their new position.
			link.transition()
			  .duration(duration)
			  .attr("d", rightAngleDiagonal);

			// Transition exiting nodes to the parent's new position.
			link.exit().transition()
			  .duration(duration)
			  .attr("d", function(d) {
				var o = {x: source.x, y: source.y};
				return rightAngleDiagonal({source: o, target: o});
			  })
			  .remove();

			// Stash the old positions for transition.
			nodes.forEach(function(d) {
			d.x0 = d.x;
			d.y0 = d.y;
			});
		};
		update(root);
      });
	});
    </script>
    <style type="text/css" media="screen">
      body { font-family: "Helvetica Neue", Helvetica, sans-serif; }
      td { vertical-align: top; }
    </style>
  </head>
 
    
  </body>
</html>